import numpy as np
from numpy.linalg import inv

# Takes in three parameters:
#   Two arrays of the same size representing a set of
#       x positions and functional values at those positions
#   A float representing the position at which the funtion
#       will be estimated at
# Uses Neville's interpolation to estimate the functional
#   value at the desired point
def Neville(x, f, y):
    n = len(x)
    Q = np.zeros((n, n))
    for i in range(n):
        Q[i][0] = f[i]

    for i in range(1, n):
        for j in range(1, i + 1):
            term1 = (y - x[i-j]) * Q[i][j-1]
            term2 = (y - x[i]) * Q[i-1][j-1]

            Q[i][j] = (term1 - term2) / (x[i] - x[i-j])

    print(Q[n-1][n-1], end = '\n\n')

# Takes in two parameters:
#   An array of x positions
#   An array of functional values at those x positions
# Uses Newton's forward method to generate a matrix
#   to be used for estimating functional values
def divided_diff_Newton(x, f):
    n = len(x)
    matrix = np.zeros((n, n))
    matrix_diag = np.zeros(n-1)

    
    for i in range(n):
        matrix[i][0] = f[i]
    
    for i in range(1, n):
        for j in range(1, i+1):
            numerator = matrix[i][j-1] - matrix[i-1][j-1]
            denominator = x[i] - x[i-j]
            matrix[i][j] = numerator / denominator
    
    for i in range(1, n):
        matrix_diag[i-1] = matrix[i][i]
    print(matrix_diag, end='\n\n')
    
    return matrix

# Takes in three parameters:
#   A matrix generated by the divided_diff_Newton function
#   An array of x positions
#   A float representing a position for which the function
#       will be estimated at
# Calculates the estimated functional value at the position
#   passed to the function
def dd_aprox_result_Newton(matrix, x, val):
    x_span = 1
    px_result = matrix[0][0]
    
    for i in range(1, len(x)):
        poly_coeff = matrix[i][i]
        x_span *= (val - x[i-1])
        
        px_result += poly_coeff * x_span
    
    return px_result

# Takes in three parameters:
#   An array of x positions
#   An array of functional values at those positions
#   An array of functional derivatives as those positions
# Sets up a matrix to be filled used the Hermite method
#   for generating a divided difference matrix
def dd_matrix_Hermite(x, f, df):
    n = len(x)
    matrix = np.zeros((2*n, 2*n))
    
    for i in range(n):
        matrix[2*i][0] = x[i]
        matrix[2*i+1][0] = x[i]
    
    for i in range(n):
        matrix[2*i][1] = f[i]
        matrix[2*i+1][1] = f[i]
    
    for i in range(n):
        matrix[2*i+1][2] = df[i]
    
    matrix = dd_fill_Hermite(matrix, 2*n)
    return matrix

# Takes in two parameters:
#   A matrix set up by the dd_matrix_Hermite function
#   An integer representing the size of the matrix
# Uses the same method for filling the divided difference
#   matrix as used in the Newton method but being careful not
#   to recalculate values previously filled in by the
#   dd_matrix_Hermite function
def dd_fill_Hermite(matrix, n):
    for i in range(2, n):
        for j in range(2, i+2):
            if j >= len(matrix[i]) or (j == 2 and i % 2 == 1):
                continue
            
            left = matrix[i][j-1]
            dia_left = matrix[i-1][j-1]
            
            numerator = left - dia_left
            denominator = matrix[i][0] - matrix[i-j+1][0]
            
            matrix[i][j] = numerator / denominator
    
    return matrix

# Takes in two parameters:
#   An array of x positions
#   An array of functional values at those positions
# Uses the cubic spline method to generate an interpolation
#   matrix used for estimating functional values
# Prints the interpolation matrix and the corresponding vectors
#   used for calculating the splines
def cubic_Spline(x, f):
    n = len(x)
    h = np.zeros(n - 1)
    c = np.zeros(n)
    b = np.zeros(n)
    A = np.zeros((n, n))
    
    for i in range(n - 1):
        h[i] = (x[i + 1] - x[i])
    
    A[0][0] = 1; A[n-1][n-1] = 1
    for i in range(1, n - 1):
        A[i][i - 1] = h[i - 1]
        A[i][i] = 2 * (h[i - 1] + h[i])
        A[i][i + 1] = h[i]
    
    for i in range(1, n - 1):
        b[i] = (3 * (f[i + 1] - f[i])) / h[i] - \
               (3 * (f[i] - f[i - 1])) / h[i - 1]
    
    c = np.dot(inv(A), b)
    
    print(A, end='\n\n')
    print(b, end='\n\n')
    print(c)
    return

def main():
    # Question 1
    x_nev = [3.6, 3.8, 3.9]
    f_nev = [1.675, 1.436, 1.318]
    Neville(x_nev, f_nev, 3.7)

    # Question 2
    x_newt = [7.2, 7.4, 7.5, 7.6]
    f_newt = [23.5492, 25.3913, 26.8224, 27.4589]
    dd_matrix = divided_diff_Newton(x_newt, f_newt)

    # Question 3
    print(dd_aprox_result_Newton(dd_matrix, x_newt, 7.3), end = '\n\n')

    # Set print options for questions 4 and 5
    np.set_printoptions(precision=7, suppress=True, linewidth=100)

    # Question 4
    x_her = [3.6, 3.8, 3.9]
    f_her = [1.675, 1.436, 1.318]
    df_her = [-1.195, -1.188, -1.182]
    matrix_her = dd_matrix_Hermite(x_her, f_her, df_her)
    print(matrix_her, end='\n\n')

    # Question 5
    x_spline = [2, 5, 8, 10]
    f_spline = [3, 5, 7, 9]
    cubic_Spline(x_spline, f_spline)
    
main()